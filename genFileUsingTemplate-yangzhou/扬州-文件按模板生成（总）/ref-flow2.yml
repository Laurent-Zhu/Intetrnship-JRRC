- name: 声明相关变量
  code: declared.operations
  args:
    payload:
      llm:
        name: '<context#model>'
        temperature: <context#temperature>
      role_prompt: |-
        <context#role_prompt>
      bot_name: '<context#bot_name>'
      qa_search_size: <context#qa_search_size>
      kl_search_size: <context#kl_search_size>
      history_turns: <context#history_turns>
      standard_term: '<context#standard_term>'
      qa_database_name: <context#qa_database_name>
      knowledge_id_list: <context#knowledge_id_list>
      qa_knowledge_id: '<context#qa_knowledge_id>'

- name: 获取历史记录
  code: memories.storage0#messages
  sinks:
    context: history
  
- name: 创建数据库表
  code: mysql.operations#execute
  args:
    statement: |-
      CREATE TABLE IF NOT EXISTS {context#qa_database_name} (
        id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,  -- 唯一标识
        question TEXT NOT NULL,
        answer TEXT NOT NULL,
        update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP  -- 自动更新时间戳
      );
    commit: true
  sinks:
    # context: qa_database_name
    logging: true

- name: 直接回答
  code: sources.execution
  args:
    locals:
      question: "{context#question}"
      qa_database_name: "{context#qa_database_name}"
    source: |-
      question = question.replace('\n', '')
      direct_answer = self.flows.plugin('mysql.operations').execute(context.subs(payload={'statement': 'SELECT answer FROM {qa_database_name} WHERE question = "{question}" LIMIT 1;'}))
      logging.info(f"direct_answer: {direct_answer}")
      if direct_answer and len(direct_answer) > 0:
          text = direct_answer[0]['answer']
          text = text.replace('#', '').replace('*', '')
          lines = [line for line in text.splitlines() if line.strip()]
          text = '\n'.join(lines)  
          res = 1
      else:
          text = ''
          res = 0
      result = {
          "text": text,
          "res": res
      }
      return result
  sinks:
    context: direct_answer
    logging: true


- name: 打印
  code: reply.operations
  args:
    pending: "{context#direct_answer.text}"

- name: 判断
  code: logics.case
  args:
    - when: int({context#direct_answer.res}) == 1
      then: 
        - name: 停止
          code: abort.operations
    - else:
        - name: 判断语言
          code: sources.execution
          args:
            source: |-
              def main():
                    
                  import re
                  
                  def detect_language(text):
                      """
                      检测文本语言类型：中文、英文、蒙语
                      返回: 'chinese', 'english', 'mongolian'
                      """
                      if not text or not text.strip():
                          return 'chinese'  # 默认中文
                      
                      text = text.strip()
                      total_chars = len(text)
                      
                      # 统计各种字符数量
                      chinese_chars = 0
                      english_chars = 0
                      mongolian_chars = 0
                      
                      for char in text:
                          # 中文字符 (包括标点符号)
                          if '\u4e00' <= char <= '\u9fff' or '\u3400' <= char <= '\u4dbf':
                              chinese_chars += 1
                          # 英文字符
                          elif char.isalpha() and ord(char) < 128:
                              english_chars += 1
                          # 蒙古文字符 (传统蒙古文)
                          elif '\u1800' <= char <= '\u18af':
                              mongolian_chars += 1
                          # 蒙古文扩展字符
                          elif '\u11ee' <= char <= '\u11f9':
                              mongolian_chars += 1
                      
                      # 计算各语言字符占比
                      chinese_ratio = chinese_chars / total_chars if total_chars > 0 else 0
                      english_ratio = english_chars / total_chars if total_chars > 0 else 0
                      mongolian_ratio = mongolian_chars / total_chars if total_chars > 0 else 0
                      
                      # 判断逻辑：优先级 蒙语 > 中文 > 英文
                      if mongolian_ratio > 0.1:  # 蒙语字符占比超过10%
                          return 'mongolian'
                      elif chinese_ratio > 0.3:  # 中文字符占比超过30%
                          return 'chinese'
                      elif english_ratio > 0.5:  # 英文字符占比超过50%
                          return 'english'
                      else:
                          # 如果都不满足，按最高占比判断
                          max_ratio = max(chinese_ratio, english_ratio, mongolian_ratio)
                          if max_ratio == mongolian_ratio and mongolian_ratio > 0:
                              return 'mongolian'
                          elif max_ratio == chinese_ratio:
                              return 'chinese'
                          elif max_ratio == english_ratio:
                              return 'english'
                          else:
                              return 'chinese'  # 默认中文
                  
                  # 获取用户输入
                  user_input = "{context#question}"
                  detected_lang = detect_language(user_input)
                  
                  # 返回语言信息
                  return detected_lang
              return main()
          sinks:
            context: language_info
            logging: true

        - name: 获取当前时间, 星期几
          code: sources.execution
          args:
            source: |-
              from datetime import datetime

              # 获取当前时间
              now = datetime.now()
              
              # 中文星期几映射
              weekday_map = {
                  0: "星期一",
                  1: "星期二",
                  2: "星期三",
                  3: "星期四",
                  4: "星期五",
                  5: "星期六",
                  6: "星期日"
              }
              
              # 获取星期几
              weekday = weekday_map[now.weekday()]
              return weekday
          sinks:
            context: weekday
            logging: true

        - name: 提问改写，关键词提取 
          code: llmx.predict.chat
          steps: |-
            { "id": 1, "content": "正在分析您的问题..." }
          args:
            messages:
              - type: system
                template: |-
                  ## Role
                  你的任务是分析用户的提问，结合上下文理解其真实意图，并对提问进行优化。

                  ## 核心任务
                  分析用户的提问和对话历史，并从以下两种操作中选择一种执行：

                  1.  **改写问题**: 如果用户的提问模糊、不完整或严重依赖上下文，请将其改写成一个独立、清晰、完整的专业问题。
                      - 改写后的问题应融入上下文中的相关信息。

                  2.  **无需改写**: 如果用户的提问已经非常清晰、具体、完整，无需修改。
                      - 在这种情况下，你必须输出固定的标志: `NO_REWRITE_NEEDED`。

                  ## 输入
                  - 用户提问: 用户的最新问题。
                  - 上下文: 此前的对话历史。

                  ## 输出格式
                  你的输出**必须**是以下两者之一，不包含任何前缀或解释：
                  - 改写后的完整问题
                  - 固定的标志: `NO_REWRITE_NEEDED`

                  ## 名词解释
                  {standard_term}

                  ## 示例
                  ### 示例 1: 改写问题
                  **输入:**
                  - 用户提问: "这个要怎么处理？"
                  - 上下文: (之前在讨论不合格品)
                  **输出:**
                  不合格品要怎么处理？

                  ### 示例 2: 无需改写
                  **输入:**
                  - 用户提问: "请介绍一下生益科技S1141板材的详细生产工艺流程。"
                  - 上下文: (无相关上下文)
                  **输出:**
                  NO_REWRITE_NEEDED
              - type: placeholder
                variable: history3
              - type: human
                template: |-
                  {content}
          sinks:
            logging: true
            context: search_words

        - name: 限制历史记录条数
          code: sources.execution
          args:
            locals:
              history: "{context#history}"
              max_turns: "{context#history_turns}"
            source: |-
              from langchain.schema import HumanMessage, AIMessage
              
              # 如果历史记录超过最大轮数，只保留最近的几轮对话
              if isinstance(history, list) and len(history) > max_turns * 2:
                  history = history[-max_turns * 2:]
              
              return history
          sinks:
            context: history5
            logging: true

        - name: 获取意图识别历史记录
          code: topics.memory.operations#get
          args:
            key: query
          sinks:
            context: query

        - name: 获取上一个知识库召回内容
          code: topics.memory.operations#get
          args:
            key: item_snippet_history
          sinks:
            context: item_snippet_history

        - name: 如果为空则初始化为""
          code: sources.execution
          args:
            source: |-
              query = """{context#query}"""
              if not query or query == """context#query""" or query == None:
                query = ""
              return query
          sinks:
            context: query
            logging: true
        

        - name: 如果等于NO_REWRITE_NEEDED，则直接返回
          code: sources.execution
          args:
            locals:
              search_words: "{context#search_words}"
              content: "{context#question}"
            source: |-
              if search_words == "NO_REWRITE_NEEDED":
                res = content
              else:
                res = search_words
              return res
          sinks:
            context: search_words
            logging: true

        - name: 从知识库中检索相关文档
          code: knowledge.hybrid.operations#similar
          args:
            knowledge: "{context#qa_knowledge_id}"
            kwargs:
              query: "{context#content}"
              dialect: "default"
              threshold:
                enabled: true
                value: 0.2
              rerank:
                enabled: true
                model: "gte-rerank"
              top_k: 5
            raw: true
          sinks:
            context: retrieved_documents
            logging: true

        - name: 构建检索结果为object格式，一个是大模型引用的字符串字段，一个是文件引用的字段
          code: sources.execution
          args:
            locals:
              docs: "{context#retrieved_documents}"
            source: |-
              def main(docs):
                if not docs or len(docs) == 0:
                  return {
                    "llm_context": "未找到相关文档",
                    "references": {
                      "footnotes": 0,
                      "docs": []
                    }
                  }
                
                # 构建大模型引用的字符串字段
                llm_context_parts = []
                references_docs = []
                
                for i, doc in enumerate(docs):
                  content = doc.page_content if hasattr(doc, 'page_content') else doc.content
                  metadata = doc.metadata if hasattr(doc, 'metadata') else {}
                  
                  # 提取标题
                  lines = content.split("\n")
                  title = lines[0].replace("# ", "") if lines and lines[0].startswith("# ") else f"文档{i+1}"
                  
                  # 构建大模型引用字符串
                  llm_context_parts.append(f"[^{i+1}] {title}: {content}")
                  
                  # 构建文件引用对象
                  doc_id = metadata.get("docs", "")
                  ref = {
                    "id": doc_id,
                    "type": "raw",
                    "title": title,
                    "filename": title + ".docx",
                    "directory": None,
                    "link": f"https://apps-dev1.aquaintelling.com/api/de-connect/de001/docs/{doc_id}",
                    "preview_type": "file",
                    "pages": [{
                      "number": 1,
                      "content": content,
                      "fn": i + 1
                    }]
                  }
                  references_docs.append(ref)
                
                return {
                  "llm_context": "\n\n".join(llm_context_parts),
                  "references": {
                    "footnotes": len(references_docs),
                    "docs": references_docs
                  }
                }
              return main(docs)
          sinks:
            context: search_results
            logging: true

        - name: 意图识别重建
          code: llmx.predict.chat
          steps: |-
            { "id": 1, "content": "正在分析您的问题..." }
          args:
            llm:
              name: gpt-4o-2024-08-06
              temperature: 0.1
            messages:
              - type: system
                template: |-
                  # Role: 智能信息源分析师
                  **核心任务**  
                  分析用户提问，精准判断所需信息源类型（0-N个），确保回答权威性与时效性。

                  ## 可用信息源及选择标准
                  1.  **本地知识库（`local_knowledge`）**  
                      📌 *选择时机*：当"相似问答库检索结果"中存在可直接回答用户问题的匹配内容时（如政策法规、办事流程等本地化信息），启用此源。

                  2.  **实时网络检索（`realtime_search`）**  
                      📌 *选择时机*：问题涉及以下场景时启用：  
                      - 超出现有知识库的实时信息（如新闻/赛事/股价）  
                      - 跨领域通用知识（如科技进展/历史事件）  
                      - 需验证的动态数据（如机构最新联系方式）

                  3.  **历史知识模块（`history_knowledge`）**  
                      📌 *选择时机*：满足以下任一条件时启用：  
                      - 对前序回答的追问（无需新数据源）

                  ## 输入参数
                  - **相似问答库检索结果**:  
                    ```
                    {ragflow_result_qa}
                    ```
                  - ** 上一个提问召回知识库内容**:
                    ```
                    {item_snippet_history}
                    ```

                  ## 输出格式
                  你必须严格按照以下JSON格式输出，`flag`字段是一个包含零个或多个信息源标识的列表。

                  ```json
                  {{
                    "reasoning": "string",
                    "flag": ["string"]
                  }}
                  ```

                  ## Attention
                  你的输出必须严格遵循JSON格式。`reasoning`字段的分析过程至关重要。
              # - type: placeholder
              #   variable: history5
              - type: human
                template: |-
                  {query}
                  human:{content}
                  {current_district_flag}
            format: 
              type: json_schema
              json_schema:
                name: "qa_intent_rewrite"
                schema:
                  type: object
                  properties:
                    reasoning:
                      type: string
                    flag:
                      type: array
                      items:
                        type: string
                  required:
                    - reasoning
                    - flag
                  additionalProperties: false
                strict: true
            inputs:
              ragflow_result_qa: "{context#ragflow_result_qa.context}"
              llm_context: "{context#search_results.llm_context}"
          sinks:
            format:
              type: load-json-object
            context: refined_query
            logging: true
            
        - name: qa召回结果注入分支
          code: logics.case
          args:
            - when: "'local_knowledge' in '{context#refined_query.flag}'"
              then: 
                - name: 设置qa召回结果
                  code: sources.execution
                  args:
                    locals:
                      prompt_ragflow_result_qa_context: "{context#ragflow_result_qa.context}"
                    source: |-
                      prompt_ragflow_result_qa_context = prompt_ragflow_result_qa_context.replace("{", "").replace("}", "")
                      return prompt_ragflow_result_qa_context
                  sinks:
                    context: prompt_ragflow_result_qa_context
                    logging: true
            - else:
                - name: 设置qa召回结果为空
                  code: sources.execution
                  args:
                    source: |-
                      prompt_ragflow_result_qa_context = ""
                      return prompt_ragflow_result_qa_context
                  sinks:
                    context: prompt_ragflow_result_qa_context
                    logging: true
        
        - name: realtime_search召回结果注入分支
          code: logics.case
          args:
            - when: "'realtime_search' in '{context#refined_query.flag}' and {context#is_internet_search} == 1"
              then: 
                - name: 日期获取
                  code: sources.execution
                  args:
                    source: |-
                      from datetime import datetime, timedelta
                      current_date = datetime.now().date()
                      date_360 = current_date - timedelta(days=360)
                      date_720 = current_date - timedelta(days=720)
                      date_1440 = current_date - timedelta(days=1440) 
                      date_100 = current_date - timedelta(days=100)
                      current_date = current_date.strftime("%Y-%m-%d")
                      date_360 = date_360.strftime("%Y-%m-%d")
                      date_720 = date_720.strftime("%Y-%m-%d")
                      date_1440 = date_1440.strftime("%Y-%m-%d")
                      date_100 = date_100.strftime("%Y-%m-%d")
                      result = {'current_date': current_date, 'date_360': date_360, 'date_720': date_720, 'date_1440': date_1440, 'date_100': date_100}
                      return result
                  sinks:
                    logging: true
                    context: dates

                - name: 生成联网问答搜索词
                  code: llmx.predict.chat
                  steps: |-
                    { "id": 1, "content": "正在联网搜索中..." }
                  args:
                    messages:
                      - type: system
                        template: |-
                          # Role
                          bingsearch 网络搜索专家

                          ## Goal
                          设计并构建合适的搜索词，搜索数量，搜索时间范围，以获取最准确、最全面的搜索结果  

                          ## Skills
                          以下是最常用、简单高效的网络搜索技巧：

                          ### 1. 精准关键词  
                          直接使用核心关键词，避免长句子或问句。  
                          例如：电脑卡顿解决办法

                          ### 2. 使用引号 ("")  
                          精确匹配短语或固定表达。  
                          例如："人工智能的未来"

                          ### 3. 使用减号 (-)  
                          排除不相关内容。  
                          例如：Python 教程 -蛇

                          ### 4. 站点搜索 (site:)  
                          限定在特定网站搜索。  
                          例如：人工智能 site:baidu.com

                          ## Example
                          input: "深圳这两年的经济运行情况怎么样？"
                          output:
                          [{{
                            "query": "深圳 经济运行 最新",
                            "count": 10,
                            "freshness": "{context#dates.date_720}..{context#dates.current_date}"
                          }}]
                          input: "中国和非洲国家最近的外交关系如何？"
                          output:
                          [{{
                            "query": "中国 非洲 外交关系 最新",
                            "count": 10,
                            "freshness": "{context#dates.date_100}..{context#dates.current_date}"
                          }}]
                          input: "初创融资需要弄明白的问题？"
                          output:
                          [{{
                            "query": "初创融资常见的误区与注意事项",
                            "count": 3,
                            "freshness": ""
                          }},
                          {{
                            "query": "初创企业融资基本流程",
                            "count": 3,
                            "freshness": ""
                          }},
                          {{
                            "query": "2024年初创企业融资趋势",
                            "count": 3,
                            "freshness": ""
                          }},
                          {{
                            "query": "初创融资需要弄明白的问题",
                            "count": 3,
                            "freshness": ""
                          }}]

                          ## 字段解释
                          - query: 搜索词
                          - count: 搜索数量
                          - freshness: 搜索时间范围，可以为空表示不限制

                          ## Rules
                          1. 单条关键词搜索默认搜索数量为5-10条，简单问题可搜索3-5条
                          2. 搜索时间范围默认为空，除非明确表示时间，eg: 最近一年，则搜索时间范围为一年
                          3. 一般问题使用一个列表对象即可，复杂问题则可返回多个搜索关键词
                          4. 多条搜索时搜索总数不超过12条！

                          ## OutputFormat
                          Array of objects

                          ## Constrains:
                          今天时间是{context#dates.current_date}
                      - type: human
                        template: |-
                          原始提问：{content}
                          修正后的提问：{search_words}
                    inputs:
                      content: "{context#question}"
                      search_words: "{context#search_words}"
                  sinks:
                    format:
                      type: load-json-object
                    context: search_query
                    logging: true
                
                - name: 默认值
                  code: sources.execution
                  args:
                    source: |-
                      def process_search_query(query_obj):
                          # 默认值
                          default_query = [{
                              "query": "{context#question}",
                              "count": 10,
                              "freshness": f"{context#dates.date_720}..{context#dates.current_date}"
                          }]
                          
                          try:
                              # 处理None或空值情况
                              if not query_obj:
                                  return default_query
                              
                              # 如果输入是字符串，尝试解析为JSON
                              if isinstance(query_obj, str):
                                  try:
                                      import json
                                      query_obj = json.loads(query_obj)
                                  except:
                                      return default_query
                              
                              # 如果是单个查询对象，转换为列表
                              if isinstance(query_obj, dict):
                                  query_obj = [query_obj]
                              
                              # 如果已经是列表格式
                              if isinstance(query_obj, list):
                                  result = []
                                  for item in query_obj:
                                      # 处理每个查询对象
                                      if isinstance(item, dict):
                                          query = item.get("query", "")
                                          count = item.get("count", 10)
                                          freshness = item.get("freshness", "")
                                          
                                          # 如果query是context占位符，使用content
                                          if str(query).startswith("context#"):
                                              query = "{context#question}"
                                          
                                          # 如果freshness是context占位符或为空，使用默认值
                                          if not freshness or str(freshness).startswith("context#"):
                                              freshness = f"{context#dates.date_720}..{context#dates.current_date}"
                                          
                                          result.append({
                                              "query": query,
                                              "count": count,
                                              "freshness": freshness
                                          })
                                  return result if result else default_query
                              
                              # 其他情况返回默认值
                              return default_query
                              
                          except Exception as e:
                              print(f"Error processing search query: {str(e)}")
                              return default_query
                      
                      # 获取并处理搜索查询
                      search_query = {context#search_query}
                      result = process_search_query(search_query)
                      
                      # 确保返回的是列表格式
                      if not isinstance(result, list):
                          result = [result] if result else [{
                              "query": "{context#question}",
                              "count": 10,
                              "freshness": f"{context#dates.date_720}..{context#dates.current_date}"
                          }]
                      
                      return result
                  sinks:
                    context: search_query
                    logging: true

                - name: 循环处理搜索词
                  code: logics.loop
                  args:
                    iterable: "{context#search_query}"
                    threads: 3
                    consumer:
                      - name: 搜索国家信息
                        code: internets.search.bing
                        # steps: |-
                        #   { "id": 1, "content": "==>>>正在联网搜索中...==>>>" }
                        args:
                          timeout: 10
                          keywords: "{context#x.query}"
                          freshness: "{context#x.freshness}"
                          scope: full
                          limit: "{context#x.count}"
                        sinks:
                          context: 
                            scope: origin
                            type: extend-props
                            name: web_search_result_list
                          logging: true

                - name: 格式化搜索结果为大模型输入
                  code: sources.execution
                  args:
                    source: |-
                      def format_for_llm(web_search_result):
                          try:
                              # 检查输入是否为列表且非空
                              if not isinstance(web_search_result, list):
                                  print(f"预期列表类型，但获得了 {type(web_search_result)}")
                                  return {"context": "", "references": {"webs": [], "footnotes": 0}}
                              
                              if not web_search_result:
                                  print("搜索结果列表为空")
                                  return {"context": "", "references": {"webs": [], "footnotes": 0}}
                              
                              context_parts = []
                              references = {"webs": [], "footnotes": 0}
                              
                              for idx, result in enumerate(web_search_result, 1):
                                  try:
                                      # 获取标题和内容，优先使用snippet字段
                                      title = result.get("title", "")
                                      content = result.get("snippet", result.get("content", ""))
                                      link = result.get("link", "")
                                      
                                      # 跳过没有有效内容的结果
                                      if not title and not content:
                                          print(f"跳过索引 {idx} 处的空结果")
                                          continue
                                      
                                      # 构建上下文部分
                                      context_parts.extend([
                                          f"[^{idx}]{title}",
                                          "=====",
                                          content,
                                          "====="
                                      ])
                                      
                                      # 构建引用部分
                                      ref_entry = {
                                          "title": title,
                                          "link": link,
                                          "snippet": content,
                                          "fn": idx,
                                      }
                                      references["webs"].append(ref_entry)
                                      
                                  except Exception as e:
                                      print(f"处理结果 {idx} 时出错: {str(e)}")
                                      continue
                              
                              references["footnotes"] = len(references["webs"])
                              
                              result = {
                                  "context": "\n".join(context_parts),
                                  "references": references
                              }
                              
                              return result
                          except Exception as e:
                              print(f"format_for_llm 函数出错: {str(e)}")
                              return {"context": "", "references": {"webs": [], "footnotes": 0}}

                      # 获取搜索结果并格式化
                      web_search_result = {context#web_search_result_list}
                      result = format_for_llm(web_search_result)
                      
                      return result
                  sinks:
                    context: web_search_result_clean
                    logging: true

        - name: history_knowledge prompt注入分支
          code: logics.case
          args:
            - when: "'history_knowledge' in '{context#refined_query.flag}'"
              then:
   
                - name: 设置历史知识
                  code: sources.execution
                  args:
                    locals:
                      prompt_item_snippet_history: "{context#item_snippet_history}"
                    source: |-
                      prompt_item_snippet_history = prompt_item_snippet_history.replace("{", "").replace("}", "")
                      return prompt_item_snippet_history
                  sinks:
                    context: prompt_item_snippet_history
                    logging: true
            - else:
                - name: 设置历史知识
                  code: sources.execution
                  args:
                    source: |-
                      prompt_item_snippet_history = ""
                      return prompt_item_snippet_history
                  sinks:
                    context: prompt_item_snippet_history
                    logging: true

        - name: 从知识库中检索相关文档
          code: knowledge.hybrid.operations#similar
          args:
            knowledge: "{context#qa_knowledge_id}"
            kwargs:
              query: "{context#content}"
              dialect: "default"
              threshold:
                enabled: true
                value: 0.2
              rerank:
                enabled: true
                model: "gte-rerank"
              top_k: 5
            raw: true
          sinks:
            context: retrieved_documents
            logging: true


        - name: 合并搜索结果
          code: sources.execution
          args:
            locals:
              refined_query_flag: "{context#refined_query.flag}"
              ragflow_result: "{context#ragflow_result}"
              web_search_result_clean: "{context#web_search_result_clean}"
            source: |-
              # 初始化结果
              combined_context_parts = []
              combined_references = {"webs": [], "footnotes": 0}
              current_fn = 1
              
              # 处理ragflow结果（如果存在）
              if ragflow_result and ragflow_result.get("llm_context"):
                  ragflow_context = ragflow_result.get("llm_context", "")
                  ragflow_refs = ragflow_result.get("references", {}).get("docs", [])
                  
                  if ragflow_context:
                      # 重新编号ragflow的上下文引用
                      import re
                      def update_ragflow_reference_numbers(text, start_num):
                          def replace_ref(match):
                              return f"[^{start_num + int(match.group(1)) - 1}]"
                          return re.sub(r'\[\^(\d+)\]', replace_ref, text)
                      
                      updated_ragflow_context = update_ragflow_reference_numbers(ragflow_context, current_fn)
                      combined_context_parts.append(updated_ragflow_context)
                      
                  # 添加ragflow引用，转换为webs格式并更新编号
                  for ref in ragflow_refs:
                      # 从docs格式转换为webs格式，保留完整字段信息
                      pages = ref.get("pages", [])
                      if pages:
                          page = pages[0]
                          web_ref = {
                              "id": ref.get("id", ""),
                              "type": ref.get("type", "raw"),
                              "title": ref.get("title", "未命名文档"),
                              "filename": ref.get("filename", ""),
                              "directory": ref.get("directory"),
                              "link": ref.get("link", ""),
                              "preview_type": ref.get("preview_type", "file"),
                              "snippet": page.get("content", "")[:500],
                              "fn": current_fn,
                              "pages": [{
                                  "number": page.get("number", 1),
                                  "content": page.get("content", ""),
                                  "fn": current_fn
                              }]
                          }
                          combined_references["webs"].append(web_ref)
                          current_fn += 1
              
              # 处理网络搜索结果（如果存在）
              if "realtime_search" in refined_query_flag and web_search_result_clean and web_search_result_clean.get("context"):
                  web_context = web_search_result_clean.get("context", "")
                  web_refs = web_search_result_clean.get("references", {}).get("webs", [])
                  
                  if web_context:
                      # 重新编号网络搜索结果的上下文
                      import re
                      def update_reference_numbers(text, start_num):
                          def replace_ref(match):
                              return f"[^{start_num + int(match.group(1)) - 1}]"
                          return re.sub(r'\[\^(\d+)\]', replace_ref, text)
                      
                      updated_web_context = update_reference_numbers(web_context, current_fn)
                      combined_context_parts.append(updated_web_context)
                      
                  # 添加网络搜索引用，更新编号
                  for ref in web_refs:
                      ref_copy = ref.copy()
                      ref_copy["fn"] = current_fn
                      combined_references["webs"].append(ref_copy)
                      current_fn += 1
              
              # 更新footnotes计数
              combined_references["footnotes"] = len(combined_references["webs"])
              
              # 组合最终结果
              final_result = {
                  "context": "\n".join(combined_context_parts),
                  "references": combined_references
              }
              
              return final_result
          sinks:
            context: final_search_result
            logging: true

        - name: 判断是否为0
          code: logics.case
          args:
            - when: "{context#ragflow_result.references.footnotes} == 0"
              then:
                - name: 回答问题
                  code: reply.operations
                  args:
                    pending: "抱歉，目前没有这方面的相关信息呢~"
            
            - else:
                - name: 大模型回答  
                  code: llmx.predict.chat
                  steps: |-
                    { "id": 1, "content": "正在努力回答您的问题..." }
                  args:
                    # llm:
                    #   name: qwen-plus
                    messages:
                      - type: system
                        template: |-
                          {role_prompt}

                          ## 知识库
                          {final_search_result}

                          ## 历史知识
                          {prompt_item_snippet_history}

                          ## 相似问答库
                          {prompt_ragflow_result_qa_context}

                          ## Attention
                          - 使用[^x]格式来引用知识库中的内容，x为引用内容的编号。
                          - 没有相关信息时，请回答：抱歉，目前没有这方面的相关信息呢~
                      - type: placeholder
                        variable: history5
                      - type: human
                        template: |-
                          {content}
                    reply: pending
                    inputs:
                      final_search_result: "{context#final_search_result.context}"
                  sinks:
                    logging: true
                    context: llm_answer2

                - name: 判断回答是否为抱歉，目前没有这方面的相关信息呢~
                  code: sources.execution
                  args:
                    source: |-
                      if """抱歉，目前没有这方面的相关信息呢~""" in """{context#llm_answer}""":
                        res = 1
                      else:
                        res = 0
                      return res
                  sinks:
                    context: rec_flag
                    logging: true

                - name: 记录数据
                  code: logics.case
                  args:
                    - when: "{context#rec_flag} == 1"
                      then:
                        - name: 创建表格(如果不存在)
                          code: mysql.operations#execute
                          args:
                            statement: |-
                              CREATE TABLE IF NOT EXISTS unanswered_questions (
                                id VARCHAR(32),
                                category VARCHAR(32),
                                question VARCHAR(5000),
                                updated_at VARCHAR(32)
                              );
                          sinks:
                            logging: true
                            
                        - code: table.operations#insert
                          name: mysql数据插入
                          args:
                            tbl: 
                              name: unanswered_questions
                              columns:                      
                                - name: id
                                  type: VARCHAR(32)
                                - name: category
                                  type: VARCHAR(32)
                                - name: question
                                  type: VARCHAR(5000)
                                - name: updated_at
                                  type: VARCHAR(32)
                            rows:
                              - id: '{context#visitor_id}'
                                category: '{context#bot_name}'
                                question: '{context#question}'
                                updated_at: '{context#now}'

- name: 判断是否引用知识库
  code: sources.execution
  args:
    locals:
      llm_answer: "{context#llm_answer2}"
    source: |-
      # 假设引用标记总是以[^开头加数字和]结尾
      res = 0
      for i in range(1, 11):
        if f"[^{i}]" in llm_answer:
          res = 1
          break
      return res
  sinks:
    context: is_reference
    logging: true

- name: 有引用则格式化引用
  code: logics.case
  args:
    - when: "{context#is_reference} == 1"
      then:
        - name: 统一格式化引用
          code: sources.execution
          args:
            locals:
              llm_answer: "{context#llm_answer2}"
              final_search_result: "{context#final_search_result}"
            source: |-
              import json
              import re

              # Extract cited reference numbers (e.g., from "[^1]") into a set for efficient lookup.
              # Using `llm_answer or ""` handles potential None values gracefully.
              try:
                  used_indices = set(map(int, re.findall(r'\[\^(\d+)\]', llm_answer or '')))
              except (ValueError, TypeError):
                  used_indices = set()

              # Safely and concisely extract the list of all reference candidates.
              all_references = final_search_result.get("references", {}).get("webs", [])

              # Filter references to keep only those cited, ensuring data integrity.
              cited_webs = [
                  ref for ref in all_references
                  if isinstance(ref, dict) and ref.get("fn") in used_indices
              ] if isinstance(all_references, list) else []

              # Build the final JSON result.
              result = {"webs": cited_webs, "footnotes": len(cited_webs)}

              return json.dumps(result, ensure_ascii=False)
          sinks:
            reply: links
            context: linkReference
            logging: true

- name: 构建上下文
  code: sources.execution
  args:
    source: |-
      # 获取当前query中的历史对话
      query = """{context#query}"""
      
      # 将历史记录按对话轮次分割
      dialog_pairs = []
      current_pair = []
      
      # 按行分割并解析human/ai对话
      lines = query.strip().split('\n')
      for line in lines:
          line = line.strip()
          if line.startswith('human:'):
              if current_pair and len(current_pair) == 2:
                  dialog_pairs.append(current_pair)
                  current_pair = []
              current_pair = [line]
          elif line.startswith('ai:') and current_pair:
              current_pair.append(line)
              
      # 添加最后一组对话
      if current_pair and len(current_pair) == 2:
          dialog_pairs.append(current_pair)
      
      # 只保留最近5轮对话
      if len(dialog_pairs) > 5:
          dialog_pairs = dialog_pairs[-5:]
      
      # 添加当前新的对话
      current_content = """{context#question}"""
      current_answer = """{context#llm_answer2}"""
      dialog_pairs.append([f"human:{current_content}", f"ai:{current_answer}"])
      
      # 重新组装对话历史
      formatted_dialog = []
      for pair in dialog_pairs:
          formatted_dialog.extend(pair)
      
      return "\n".join(formatted_dialog)
  sinks:
    context: query
    logging: true

- name: 保存query
  code: topics.memory.operations#put
  args:
    key: query
    value: "{context#query}"
  sinks:
    logging: true

- name: 是否需要拓展问答
  code: logics.case
  args:
    - when: "{context#extra_question} == 1"
      then:
        - name: 扩展问答
          code: llmx.predict.chat
          args:
            llm:
              model: gpt-4o-mini
              temperature: 0.7
            messages:
              - type: system
                template: |-
                  # Task
                  预判用户下一步可能的提问内容，第一个问题尽量可从参考资料中回答

                  # 生成角度
                  1. 不同理论视角
                  2. 数据驱动的洞察
                  3. 行为模式分析
                  4. 情感与动机探讨
                  5. 长期趋势与预测

                  # 思考方法论
                  1. 归纳法与演绎法结合
                  2. SWOT分析（优势、劣势、机会、威胁）
                  3. 因果关系链分析
                  4. 多变量交叉分析
                  5. 假设检验与验证
                  6. 问题深度递进

                  # 答复要求
                  1. 请参考[现有提问]和[现有答案]扩展及延伸 3 条相关的提问列表。
                  2. 禁止添加任何形式的注释。 
                  3. 请使用以下 JSON 格式进行答复，仅需答复 JSON 格式内容(禁止使用"```"包裹答案，禁止添加注释):
                  {{
                    "question1": string, // 相关提问1的描述
                    "question2": string, // 相关提问2的描述
                    "question3": string // 相关提问3的描述
                  }}
              - type: placeholder
                variable: history5
              - type: human
                template: |-
                  {content}
          sinks:
            format:
              - type: load-json-object
              - type: list-dict-values
              - type: text-joining
                delimiter: "\n"
                pattern: "- {x}"
            reply: extends

- code: refs.operations
  name: 保存历史记录
  args:
    flows: chat-memories-flush.yml